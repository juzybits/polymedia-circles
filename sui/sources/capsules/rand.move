// Original file:
// https://github.com/capsule-craft/capsules/blob/master/packages/sui_utils/sources/rand.move

// This is a pseudo-random number generator; outputs will always be the same number
// given the same ctx (transaction context). Note that the ctx is mutated every time a
// number is generated, so it can be used consecutively in the same transaction, however
// the sequence of random numbers is deterministic.
//
// I don't know of any way for a user to externally "game" this; I believe the UID's
// generated by Sui are very dependent upon the chain itself.
//
// Eventually this should be replaced by a VRF from Switchboard (work in progress)

module capsules::rand {
    use std::hash;
    use std::vector;

    use sui::bcs;
    use sui::object;
    use sui::tx_context::{Self, TxContext};

    const EBAD_RANGE: u64 = 0;
    const ETOO_FEW_BYTES: u64 = 1;

    public fun rng(min: u64, max: u64, ctx: &mut TxContext): u64 {
        assert!(max >= min, EBAD_RANGE);
        let value = from_seed(seed(ctx));

        value % (max - min) + min
    }

    public fun from_seed(seed: vector<u8>): u64 {
        assert!(vector::length(&seed) >= 8, ETOO_FEW_BYTES);
        bcs::peel_u64(&mut bcs::new(seed))
    }

    // generates seed using the tx context (epoch, sender and a newly created uid)
    public fun seed(ctx: &mut TxContext): vector<u8> {
        let raw_seed = raw_seed(ctx);
        hash::sha3_256(raw_seed)
    }

    public fun raw_seed(ctx: &mut TxContext): vector<u8> {
        let sender = tx_context::sender(ctx);
        let sender_bytes = bcs::to_bytes(&sender);

        let epoch = tx_context::epoch(ctx);
        let epoch_bytes = bcs::to_bytes(&epoch);

        let id = object::new(ctx);
        let id_bytes = object::uid_to_bytes(&id);
        object::delete(id);

        let raw_seed = vector::empty<u8>();
        vector::append(&mut raw_seed, id_bytes);
        vector::append(&mut raw_seed, epoch_bytes);
        vector::append(&mut raw_seed, sender_bytes);

        raw_seed
    }
}

#[test_only]
module capsules::rand_tests {
    use sui::test_scenario;
    use sui::tx_context::TxContext;

    use capsules::rand;

    const EOUTSIDE_RANGE: u64 = 0;
    const EONE_IN_A_MILLION_ERROR: u64 = 1;

    public fun print_rand(min: u64, max: u64, ctx: &mut TxContext): u64 {
        let num = rand::rng(min, max, ctx);
        // std::debug::print(&num);
        assert!(num >= min && num < max, EOUTSIDE_RANGE);
        num
    }

    #[test]
    public fun test1() {
        // 1st tx: must always be == 1
        let scenario = test_scenario::begin(@0x5);
        print_rand(1, 2, test_scenario::ctx(&mut scenario));

        // 2nd tx
        test_scenario::next_tx(&mut scenario, @0x5);
        print_rand(15, 99, test_scenario::ctx(&mut scenario));

        // 3rd tx
        test_scenario::next_tx(&mut scenario, @0x5);
        let r1 = print_rand(99, 1000000, test_scenario::ctx(&mut scenario));

        // 4th tx: identical range as above tx, but different outcome
        test_scenario::next_tx(&mut scenario, @0x5);
        let r2 = print_rand(99, 1000000, test_scenario::ctx(&mut scenario));
        assert!(r1 != r2, EONE_IN_A_MILLION_ERROR);

        test_scenario::end(scenario);
    }
}
